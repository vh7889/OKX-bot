import asyncio
import websockets
import time
import hmac
import hashlib
import base64
import json
import random
import string
from datetime import datetime, UTC
import requests
import os

# ‚úÖ ÁΩëÊ†ºÂºÄÂÖ≥ÂèÇÊï∞
enable_long_grid = True  # ÊòØÂê¶ÂêØÁî®Â§öÂçïÁΩëÊ†º
enable_short_grid = True  # ÊòØÂê¶ÂêØÁî®Á©∫ÂçïÁΩëÊ†º

# ‚úÖ API ÈÖçÁΩÆ
API_KEY = ""
SECRET_KEY = ""
PASSPHRASE = ""
feishu_token = ''  # È£û‰π¶TOKEN

# ‚úÖ Â§öÂçï‰∫§ÊòìÂèÇÊï∞
long_position = 0  # ÂΩìÂâçÂ§öÂçïÊåÅ‰ªì
long_trigger_price = 85802.6  # Â§öÂçïËß¶Âèë‰ª∑Ê†º
long_grid_percentage = 0.6 / 100  # Â§öÂçïÁΩëÊ†ºÈó¥Ë∑ù
long_grid_size = 0.002  # Â§öÂçïÊØèÊ¨°‰π∞ÂÖ•Èáè
long_max_position = 0.01  # Â§öÂçïÊúÄÂ§ßÊåÅ‰ªì
long_take_profit_count = 0  # Â§öÂçïÊ≠¢ÁõàÊ¨°Êï∞

# ‚úÖ Á©∫Âçï‰∫§ÊòìÂèÇÊï∞
short_position = 0.008  # ÂΩìÂâçÁ©∫ÂçïÊåÅ‰ªì
short_trigger_price = 87356.7  # Á©∫ÂçïËß¶Âèë‰ª∑Ê†º
short_grid_percentage = 0.6 / 100  # Á©∫ÂçïÁΩëÊ†ºÈó¥Ë∑ù
short_grid_size = 0.002  # Á©∫ÂçïÊØèÊ¨°ÂçñÂá∫Èáè
short_max_position = 0.01  # Á©∫ÂçïÊúÄÂ§ßÊåÅ‰ªì
short_take_profit_count = 0  # Á©∫ÂçïÊ≠¢ÁõàÊ¨°Êï∞

# ‚úÖ Â≠òÂÇ®ËÆ¢Âçï ID
buy_ordId = None
close_long_ordId = None
take_profit_count = 0
BASE_URL = "https://www.okx.com"


def save_order_info(order_type, order_id, price, pos_side=None):
    """‰øùÂ≠òËÆ¢Âçï‰ø°ÊÅØÂà∞ JSON Êñá‰ª∂
    order_type: 'buy' Êàñ 'sell'
    order_id: ËÆ¢ÂçïID
    price: ÂßîÊâò‰ª∑Ê†º
    pos_side: ÊåÅ‰ªìÊñπÂêë 'long' Êàñ 'short'
    """
    filename = 'order_records.json'
    try:
        # ËØªÂèñÁé∞ÊúâÊï∞ÊçÆ
        if os.path.exists(filename):
            with open(filename, 'r') as f:
                data = json.load(f)
        else:
            data = {'orders': {}}

        # Ê∑ªÂä†Êñ∞ËÆ¢Âçï‰ø°ÊÅØ
        data['orders'][str(order_id)] = {
            'side': order_type,
            'price': float(price),
            'pos_side': pos_side
        }

        # ‰øùÂ≠òÂà∞Êñá‰ª∂
        with open(filename, 'w') as f:
            json.dump(data, f, indent=4)

        # print(f"‚úÖ Â∑≤‰øùÂ≠òËÆ¢Âçï‰ø°ÊÅØ: ID={order_id}, ÊñπÂêë={order_type}, ÊåÅ‰ªìÊñπÂêë={pos_side}, ‰ª∑Ê†º={price}")
    except Exception as e:
        print(f"‚ùå ‰øùÂ≠òËÆ¢Âçï‰ø°ÊÅØÂ§±Ë¥•: {e}")


def get_order_info(order_id):
    """‰ªé JSON Êñá‰ª∂‰∏≠ËØªÂèñËÆ¢Âçï‰ø°ÊÅØ
    ËøîÂõû: (order_type, price, pos_side) Êàñ (None, None, None)
    """
    filename = 'order_records.json'
    try:
        if not os.path.exists(filename):
            return None, None, None

        with open(filename, 'r') as f:
            data = json.load(f)

        # Êü•ÊâæËÆ¢Âçï
        order_id = str(order_id)
        if order_id in data.get('orders', {}):
            order_info = data['orders'][order_id]
            return order_info['side'], order_info['price'], order_info['pos_side']

        return None, None, None
    except Exception as e:
        print(f"‚ùå ËØªÂèñËÆ¢Âçï‰ø°ÊÅØÂ§±Ë¥•: {e}")
        return None, None, None


def generate_clOrdId(side):
    """ÁîüÊàêÂîØ‰∏Ä clOrdId"""
    timestamp = str(int(time.time() * 1000))
    random_str = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))
    return f"{side}{random_str}{timestamp[-6:]}"[:32]


def calculate_grid_prices(trigger_price, pos_side="long"):
    """ËÆ°ÁÆóÁΩëÊ†º‰ª∑Ê†º"""
    if pos_side == "long":
        buy_price = round(trigger_price * (1 - long_grid_percentage), 2)
        close_long_price = round(trigger_price * (1 + long_grid_percentage), 2)
    else:  # short
        buy_price = round(trigger_price * (1 - short_grid_percentage), 2)
        close_long_price = round(trigger_price * (1 + short_grid_percentage), 2)
    return buy_price, close_long_price


def generate_signature(timestamp, method, request_path, body=""):
    """ÁîüÊàêÁ≠æÂêç"""
    message = timestamp + method + request_path + body
    mac = hmac.new(SECRET_KEY.encode("utf-8"), message.encode("utf-8"), hashlib.sha256)
    return base64.b64encode(mac.digest()).decode("utf-8")


def query_orders():
    """Êü•ËØ¢Áé∞ÊúâÂßîÊâòÂçï"""
    endpoint = "/api/v5/trade/orders-pending"
    url = BASE_URL + endpoint

    timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')[:23] + 'Z'
    sign = generate_signature(timestamp, "GET", endpoint)

    headers = {
        "OK-ACCESS-KEY": API_KEY,
        "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp,
        "OK-ACCESS-PASSPHRASE": PASSPHRASE,
        "Content-Type": "application/json",
    }

    try:
        response = requests.get(url, headers=headers)
        response_data = response.json()
        print(response_data)
        if response_data.get("code") == "0":
            orders = response_data.get("data", [])
            if orders:
                print("\nüìã ÂΩìÂâçÂßîÊâòÂçï:")
                for order in orders:
                    side = order.get("side", "")
                    pos_side = order.get("posSide", "")
                    price = float(order.get("px", "0"))
                    size = float(order.get("sz", "0")) / 100
                    ord_id = order.get("ordId", "")
                    state = order.get("state", "")
                    print(
                        f"  {side.upper()} {pos_side.upper()}: ‰ª∑Ê†º {price:.2f} / Êï∞Èáè {size:.4f} / Áä∂ÊÄÅ {state} / ID {ord_id}")
            return orders
        else:
            print(f"‚ùå Êü•ËØ¢ËÆ¢ÂçïÂ§±Ë¥•: {response_data.get('msg')}")
            return []

    except Exception as e:
        print(f"‚ùå Êü•ËØ¢ËÆ¢ÂçïÂèëÁîüÈîôËØØ: {str(e)}")
        return []


def cancel_order_rest_api(ord_id, inst_id):
    """‰ΩøÁî® REST API Êí§Âçï"""
    endpoint = "/api/v5/trade/cancel-order"
    url = BASE_URL + endpoint
    timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')[:23] + 'Z'

    cancel_data = {
        "ordId": ord_id,
        "instId": inst_id
    }
    cancel_json = json.dumps(cancel_data, separators=(',', ':'))

    sign = generate_signature(timestamp, "POST", endpoint, cancel_json)
    headers = {
        "OK-ACCESS-KEY": API_KEY,
        "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp,
        "OK-ACCESS-PASSPHRASE": PASSPHRASE,
        "Content-Type": "application/json",
    }

    response = requests.post(url, data=cancel_json, headers=headers)
    return response.json()


async def cancel_all_orders():
    """ÂèñÊ∂àÊâÄÊúâÊú™ÂÆåÊàêÁöÑÂßîÊâòÂçï"""
    orders = query_orders()
    for order in orders:
        ord_id = order.get('ordId')
        inst_id = order.get('instId')
        if ord_id and inst_id:
            cancel_response = cancel_order_rest_api(ord_id, inst_id)
            if cancel_response.get('code') == '0':
                print(f"‚úÖ Êí§ÂçïÊàêÂäü: {ord_id}")


def place_order(side, price, size, pos_side="long", is_close=False):
    """‰ΩøÁî®REST API‰∏ãÂçï"""
    endpoint = "/api/v5/trade/order"
    url = BASE_URL + endpoint
    timestamp = datetime.now(UTC).strftime('%Y-%m-%dT%H:%M:%S.%fZ')[:23] + 'Z'

    order_data = {
        "instId": "BTC-USDT-SWAP",
        "tdMode": "cross",
        "clOrdId": generate_clOrdId(side),
        "side": side,
        "ordType": "limit",
        "px": str(price),
        "sz": str(size * 100),
        "posSide": pos_side,
        "reduceOnly": "true" if is_close else "false"
    }

    order_json = json.dumps(order_data, separators=(',', ':'))
    sign = generate_signature(timestamp, "POST", endpoint, order_json)

    headers = {
        "OK-ACCESS-KEY": API_KEY,
        "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp,
        "OK-ACCESS-PASSPHRASE": PASSPHRASE,
        "Content-Type": "application/json",
    }

    response = requests.post(url, data=order_json, headers=headers)
    response_data = response.json()
    if response_data.get("code") == "0" and "data" in response_data and len(response_data["data"]) > 0:
        order_info = response_data["data"][0]
        order_id = order_info.get("ordId")
        if order_id:
            # ‰øùÂ≠òËÆ¢Âçï‰ø°ÊÅØ
            save_order_info(side, order_id, price, pos_side)
            return order_id
    print(f"‚ùå ‰∏ãÂçïÂ§±Ë¥•Ôºö{response_data}")
    return None


async def order_listener(websocket):
    """ÁõëÂê¨ËÆ¢ÂçïÊõ¥Êñ∞"""
    global long_position, short_position, buy_ordId, close_long_ordId, long_trigger_price, short_trigger_price, long_take_profit_count, short_take_profit_count

    subscribe_msg = {"op": "subscribe", "args": [{"channel": "orders", "instType": "SWAP"}]}
    await websocket.send(json.dumps(subscribe_msg))
    print("üì° Â∑≤ËÆ¢ÈòÖËÆ¢ÂçïÊõ¥Êñ∞")

    while True:
        try:
            response = await websocket.recv()
            response_data = json.loads(response)

            if "data" in response_data and response_data.get("arg", {}).get("channel") == "orders":
                for order_info in response_data["data"]:
                    # Ê£ÄÊü•ÊòØÂê¶‰∏∫BTC-USDT-SWAPÁöÑËÆ¢Âçï
                    if order_info.get("instId") != "BTC-USDT-SWAP":
                        continue

                    state = order_info.get("state")
                    side = order_info.get("side")
                    pos_side = order_info.get("posSide")
                    filled_size = float(order_info.get("accFillSz", "0")) / 100
                    order_price = float(order_info.get("px", "0"))
                    ordId = order_info.get("ordId")

                    # È™åËØÅËÆ¢ÂçïÊòØÂê¶Áî±Á®ãÂ∫èÂàõÂª∫
                    order_type, _, _ = get_order_info(ordId)
                    if order_type is None:  # Â¶ÇÊûúËÆ¢Âçï‰∏çÂú®ËÆ∞ÂΩï‰∏≠ÔºåËØ¥Êòé‰∏çÊòØÁ®ãÂ∫èÂàõÂª∫ÁöÑ
                        continue

                    if state == "filled" and filled_size > 0:
                        buy_price, close_price = calculate_grid_prices(order_price, pos_side)

                        # Â§ÑÁêÜÂ§öÂçï
                        if pos_side == "long" and enable_long_grid:
                            if side == "buy":
                                long_position += filled_size
                                if long_position < long_max_position:
                                    long_trigger_price = order_price
                                    print(f"\n‚úÖ ÂºÄÂ§öÊàê‰∫§")
                                    print(f"üí∞ ÂΩìÂâçÂ§öÂçïÊåÅ‰ªì: {long_position}")
                                    print(f"üéØ Â§öÂçïËß¶Âèë‰ª∑Ê†º: {long_trigger_price}")
                                    # ÂèñÊ∂àÊóßÁöÑÂπ≥Â§öÂçï
                                    orders = query_orders()
                                    for order in orders:
                                        if order.get('side') == 'sell' and order.get('posSide') == 'long':
                                            # È™åËØÅËÆ¢ÂçïÊòØÂê¶Áî±Á®ãÂ∫èÂàõÂª∫
                                            order_type, _, _ = get_order_info(order.get('ordId'))
                                            if order_type is not None:  # Âè™ÂèñÊ∂àÁ®ãÂ∫èÂàõÂª∫ÁöÑËÆ¢Âçï
                                                cancel_order_rest_api(order.get('ordId'), order.get('instId'))
                                    # ÈáçÊñ∞ÂßîÊâò‰π∞ÂçïÂíåÂçñÂçï
                                    place_order("buy", buy_price, long_grid_size, "long")
                                    place_order("sell", close_price, long_grid_size, "long", is_close=True)
                                    trigger_price = long_trigger_price
                                    grid_size = long_grid_size
                                    send_to_feishu(grid_size, grid_size, long_position, long_max_position,
                                                   trigger_price, 0,
                                                   buy_price, close_price, take_profit_count, 0, "Â§ö")
                                else:
                                    print('\n‚ö†Ô∏è ÊåÅ‰ªìÂ∑≤ËææÂà∞ÊúÄÂ§ßÔºåÂÅúÊ≠¢‰π∞ÂÖ•')
                                    orders = query_orders()
                                    for order in orders:
                                        if order.get('side') == 'sell' and order.get('posSide') == 'long':
                                            # È™åËØÅËÆ¢ÂçïÊòØÂê¶Áî±Á®ãÂ∫èÂàõÂª∫
                                            order_type, _, _ = get_order_info(order.get('ordId'))
                                            if order_type is not None:  # Âè™ÂèñÊ∂àÁ®ãÂ∫èÂàõÂª∫ÁöÑËÆ¢Âçï
                                                cancel_order_rest_api(order.get('ordId'), order.get('instId'))
                                    place_order("sell", close_price, long_grid_size, "long", is_close=True)
                                    trigger_price = long_trigger_price
                                    grid_size = long_grid_size
                                    send_to_feishu(grid_size, grid_size, long_position, long_max_position,
                                                   trigger_price, 0,
                                                   buy_price, close_price, take_profit_count, 0, "Â§ö")
                            elif side == "sell":
                                long_position -= filled_size
                                long_trigger_price = order_price
                                long_take_profit_count += 1
                                print(f"\n‚úÖ Âπ≥Â§öÊàê‰∫§")
                                print(f"üí∞ ÂΩìÂâçÂ§öÂçïÊåÅ‰ªì: {long_position}")
                                print(f"üéØ Â§öÂçïËß¶Âèë‰ª∑Ê†º: {long_trigger_price}")
                                orders = query_orders()
                                for order in orders:
                                    if order.get('side') == 'buy' and order.get('posSide') == 'long':
                                        # È™åËØÅËÆ¢ÂçïÊòØÂê¶Áî±Á®ãÂ∫èÂàõÂª∫
                                        order_type, _, _ = get_order_info(order.get('ordId'))
                                        if order_type is not None:  # Âè™ÂèñÊ∂àÁ®ãÂ∫èÂàõÂª∫ÁöÑËÆ¢Âçï
                                            cancel_order_rest_api(order.get('ordId'), order.get('instId'))
                                place_order("buy", buy_price, long_grid_size, "long")
                                place_order("sell", close_price, long_grid_size, "long", is_close=True)
                                trigger_price = long_trigger_price
                                grid_size = long_grid_size
                                send_to_feishu(grid_size, grid_size, long_position, long_max_position, trigger_price, 1,
                                               buy_price, close_price, take_profit_count, 0, "Â§ö")

                        # Â§ÑÁêÜÁ©∫Âçï
                        elif pos_side == "short" and enable_short_grid:
                            if side == "sell":
                                short_position += filled_size
                                if short_position < short_max_position:
                                    short_trigger_price = order_price
                                    print(f"\n‚úÖ ÂºÄÁ©∫Êàê‰∫§")
                                    print(f"üí∞ ÂΩìÂâçÁ©∫ÂçïÊåÅ‰ªì: {short_position}")
                                    print(f"üéØ Á©∫ÂçïËß¶Âèë‰ª∑Ê†º: {short_trigger_price}")
                                    orders = query_orders()
                                    for order in orders:
                                        if order.get('side') == 'buy' and order.get('posSide') == 'short':
                                            cancel_order_rest_api(order.get('ordId'), order.get('instId'))
                                    place_order("sell", close_price, short_grid_size, "short")
                                    place_order("buy", buy_price, short_grid_size, "short", is_close=True)
                                    trigger_price = short_trigger_price
                                    grid_size = short_grid_size
                                    send_to_feishu(grid_size, grid_size, short_position, short_max_position,
                                                   trigger_price, 0,
                                                   close_price, buy_price, short_take_profit_count, 0, "Á©∫")
                                else:
                                    print('\n‚ö†Ô∏è Á©∫ÂçïÊåÅ‰ªìÂ∑≤ËææÂà∞ÊúÄÂ§ßÔºåÂÅúÊ≠¢ÂçñÂá∫')
                                    orders = query_orders()
                                    for order in orders:
                                        if order.get('side') == 'buy' and order.get('posSide') == 'short':
                                            # È™åËØÅËÆ¢ÂçïÊòØÂê¶Áî±Á®ãÂ∫èÂàõÂª∫
                                            order_type, _, _ = get_order_info(order.get('ordId'))
                                            if order_type is not None:  # Âè™ÂèñÊ∂àÁ®ãÂ∫èÂàõÂª∫ÁöÑËÆ¢Âçï
                                                cancel_order_rest_api(order.get('ordId'), order.get('instId'))
                                    place_order("buy", buy_price, short_grid_size, "short", is_close=True)
                                    trigger_price = short_trigger_price
                                    grid_size = short_grid_size
                                    send_to_feishu(grid_size, grid_size, short_position, short_max_position,
                                                   trigger_price, 0,
                                                   close_price, buy_price, short_take_profit_count, 0, "Á©∫")
                            elif side == "buy":
                                short_position -= filled_size
                                short_trigger_price = order_price
                                short_take_profit_count += 1
                                print(f"\n‚úÖ Âπ≥Á©∫Êàê‰∫§")
                                print(f"üí∞ ÂΩìÂâçÁ©∫ÂçïÊåÅ‰ªì: {short_position}")
                                print(f"üéØ Á©∫ÂçïËß¶Âèë‰ª∑Ê†º: {short_trigger_price}")
                                orders = query_orders()
                                for order in orders:
                                    if order.get('side') == 'sell' and order.get('posSide') == 'short':
                                        # È™åËØÅËÆ¢ÂçïÊòØÂê¶Áî±Á®ãÂ∫èÂàõÂª∫
                                        order_type, _, _ = get_order_info(order.get('ordId'))
                                        if order_type is not None:  # Âè™ÂèñÊ∂àÁ®ãÂ∫èÂàõÂª∫ÁöÑËÆ¢Âçï
                                            cancel_order_rest_api(order.get('ordId'), order.get('instId'))
                                place_order("sell", close_price, short_grid_size, "short")
                                place_order("buy", buy_price, short_grid_size, "short", is_close=True)
                                trigger_price = short_trigger_price
                                grid_size = short_grid_size
                                send_to_feishu(grid_size, grid_size, short_position, short_max_position, trigger_price,
                                               1,
                                               close_price, buy_price, short_take_profit_count, 0, "Á©∫")

            await asyncio.sleep(0)

        except websockets.exceptions.ConnectionClosed:
            print("\n‚ùå WebSocket ËøûÊé•Êñ≠ÂºÄÔºåÂ∞ùËØïÈáçÊñ∞ËøûÊé•...")
            await asyncio.sleep(5)
            return
        except Exception as e:
            print(f"\n‚ö†Ô∏è ÁõëÂê¨ÂºÇÂ∏∏: {e}")


def get_account_balance():
    """Ëé∑ÂèñË¥¶Êà∑‰ΩôÈ¢ù‰ø°ÊÅØ"""
    endpoint = "/api/v5/account/balance"
    url = BASE_URL + endpoint

    timestamp = datetime.now(UTC).strftime('%Y-%m-%dT%H:%M:%S.%fZ')[:23] + 'Z'
    sign = generate_signature(timestamp, "GET", endpoint)

    headers = {
        "OK-ACCESS-KEY": API_KEY,
        "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp,
        "OK-ACCESS-PASSPHRASE": PASSPHRASE,
        "Content-Type": "application/json",
    }

    try:
        response = requests.get(url, headers=headers)
        response_data = response.json()

        if response_data.get("code") == "0":
            data = response_data.get("data", [])
            if data:
                return float(data[0].get("totalEq", "0"))
        return 0

    except Exception as e:
        print(f"‚ùå Ëé∑ÂèñË¥¶Êà∑‰ø°ÊÅØÂèëÁîüÈîôËØØ: {str(e)}")
        return 0


def send_to_feishu(grid_size, take_profit_size, current_position, max_position, trigger_price, action_type, buy_price,
                   close_long_price, take_profit_count, balance, pos_type):
    """ÂèëÈÄÅÊ∂àÊÅØÂà∞È£û‰π¶"""
    url = f"https://open.feishu.cn/open-apis/bot/v2/hook/{feishu_token}"
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    headers = {
        "Content-Type": "application/json"
    }

    # Ëé∑ÂèñË¥¶Êà∑ÊÄª‰ª∑ÂÄºÂíåÂØπÂ∫îÊñπÂêëÁöÑÊ≠¢ÁõàÊ¨°Êï∞
    total_balance = get_account_balance()
    display_take_profit_count = long_take_profit_count if pos_type == "Â§ö" else short_take_profit_count

    # Determine action and template color based on action_type
    if action_type == 1:
        action = "Ê≠¢Áõà"  # Take profit
        template_color = "green"
    elif action_type == 0:
        action = "Âä†‰ªì"  # Increase position
        template_color = "orange"
    else:
        action = "Êú™Áü•"  # Unknown action
        template_color = "wathet"  # Default color

    data = {
        "msg_type": "interactive",
        "card": {
            "config": {
                "wide_screen_mode": True
            },
            "header": {
                "title": {
                    "tag": "plain_text",
                    "content": f"ü§ñ„ÄêOKX-Êí∏Áü≠Êú∫Âô®‰∫∫„Äëü§ñ--{action}"
                },
                "template": template_color
            },
            "elements": [
                {
                    "tag": "div",
                    "text": {
                        "tag": "lark_md",
                        "content": (
                            f"**¬∑‰∫§ÊòìÂØπ:** <font color='orange'>**BTC-UÊú¨‰Ωç-{pos_type}Âπ≥**</font>  \n"
                            f"**¬∑Ëß¶Âèë‰ª∑Ê†º:** <font color='blue'>**{trigger_price}**</font> **Ë°å‰∏∫:** <font color='green'>**{action}**</font>  \n"
                            f"**¬∑ÊåÇ‰π∞Âçï‰ª∑Ê†º:** <font color='green'>**{buy_price}**</font> **Êï∞Èáè:** <font color='green'>**{grid_size}**</font>  \n"
                            f"**¬∑ÊåÇÂçñÂçï‰ª∑Ê†º:** <font color='red'>**{close_long_price}**</font> **Êï∞Èáè:** <font color='red'>**{take_profit_size}**</font>  \n"
                            f"**¬∑ÂΩìÂâçÊåÅ‰ªìÈáè:** <font color='orange'>**{current_position:.3f}**</font>  \n"
                            f"**¬∑ÊúÄÂ§ßÊåÅ‰ªìÈáè:** <font color='orange'>**{max_position}**</font>  \n"
                            f"**¬∑{pos_type}ÂçïÊ≠¢ÁõàÊ¨°Êï∞:** <font color='orange'>**{display_take_profit_count}**</font> **Ë¥¶Êà∑ÊÄª‰ª∑ÂÄº:** <font color='orange'>**{total_balance:.2f} USDT**</font>  \n"
                            f"**¬∑Êó∂Èó¥:** <font color='green'>**{current_time}**</font>"
                        )
                    }
                }
            ]
        }
    }

    response = requests.post(url, json=data, headers=headers)
    print(response.json())


async def connect_websocket():
    """WebSocket ËøûÊé•ÁÆ°ÁêÜ"""
    global buy_ordId, close_long_ordId
    is_order_placed = False
    while True:
        try:
            async with websockets.connect("wss://ws.okx.com:8443/ws/v5/private") as websocket:
                # ËÆ§ËØÅ
                timestamp = str(int(time.time()))
                message = timestamp + 'GET' + '/users/self/verify'
                signature = base64.b64encode(hmac.new(
                    SECRET_KEY.encode(), message.encode(), hashlib.sha256
                ).digest()).decode()

                auth_data = {
                    "op": "login",
                    "args": [
                        {
                            "apiKey": API_KEY,
                            "passphrase": PASSPHRASE,
                            "timestamp": timestamp,
                            "sign": signature
                        }
                    ]
                }
                await websocket.send(json.dumps(auth_data))
                response = await websocket.recv()
                print("‚úÖ ËÆ§ËØÅÁªìÊûú:", response)

                if not is_order_placed:
                    # Ê†πÊçÆÈÖçÁΩÆÂÜ≥ÂÆöÊòØÂê¶ÂßîÊâòÂ§öÂçï
                    if enable_long_grid:
                        buy_price, close_long_price = calculate_grid_prices(long_trigger_price, "long")
                        buy_ordId = place_order("buy", buy_price, long_grid_size, "long")
                        close_long_ordId = place_order("sell", close_long_price, long_grid_size, "long", is_close=True)

                    # Ê†πÊçÆÈÖçÁΩÆÂÜ≥ÂÆöÊòØÂê¶ÂßîÊâòÁ©∫Âçï
                    if enable_short_grid:
                        short_buy_price, short_close_price = calculate_grid_prices(short_trigger_price, "short")
                        place_order("sell", short_close_price, short_grid_size, "short")
                        place_order("buy", short_buy_price, short_grid_size, "short", is_close=True)

                    is_order_placed = True

                await order_listener(websocket)
        except Exception as e:
            print(f"‚ö†Ô∏è ËøûÊé•ÈîôËØØ: {e}Ôºå5ÁßíÂêéÈáçËØï...")
            await asyncio.sleep(5)
            is_order_placed = False


if __name__ == "__main__":
    print("\nüöÄ ÂêØÂä®OKXÁΩëÊ†º‰∫§ÊòìÊú∫Âô®‰∫∫...\n")
    if enable_long_grid:
        print("üìà Â§öÂçï‰∫§ÊòìÈÖçÁΩÆ:")
        print(f"  ‚Ä¢ ÂΩìÂâçÊåÅ‰ªì: {long_position}")
        print(f"  ‚Ä¢ Ëß¶Âèë‰ª∑Ê†º: {long_trigger_price}")
        print(f"  ‚Ä¢ ÁΩëÊ†ºÈó¥Ë∑ù: {long_grid_percentage * 100}%")
        print(f"  ‚Ä¢ ‰∫§ÊòìÊï∞Èáè: {long_grid_size}")
        print(f"  ‚Ä¢ ÊúÄÂ§ßÊåÅ‰ªì: {long_max_position}\n")

    if enable_short_grid:
        print("üìâ Á©∫Âçï‰∫§ÊòìÈÖçÁΩÆ:")
        print(f"  ‚Ä¢ ÂΩìÂâçÊåÅ‰ªì: {short_position}")
        print(f"  ‚Ä¢ Ëß¶Âèë‰ª∑Ê†º: {short_trigger_price}")
        print(f"  ‚Ä¢ ÁΩëÊ†ºÈó¥Ë∑ù: {short_grid_percentage * 100}%")
        print(f"  ‚Ä¢ ‰∫§ÊòìÊï∞Èáè: {short_grid_size}")
        print(f"  ‚Ä¢ ÊúÄÂ§ßÊåÅ‰ªì: {short_max_position}\n")
    asyncio.run(connect_websocket())
